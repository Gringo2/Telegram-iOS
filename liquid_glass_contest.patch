diff --git a/submodules/Display/Source/SwitchNode.swift b/submodules/Display/Source/SwitchNode.swift
index 1204a3a585..816cc044c2 100644
--- a/submodules/Display/Source/SwitchNode.swift
+++ b/submodules/Display/Source/SwitchNode.swift
@@ -1,104 +1,177 @@
 import Foundation
 import UIKit
 import AsyncDisplayKit
+import QuartzCore
 
-private final class SwitchNodeViewLayer: CALayer {
-    override func setNeedsDisplay() {
-    }
-}
-
-private final class SwitchNodeView: UISwitch {
-    override class var layerClass: AnyClass {
-        if #available(iOS 26.0, *) {
-            return super.layerClass
-        } else {
-            return SwitchNodeViewLayer.self
-        }
-    }
-}
-
-open class SwitchNode: ASDisplayNode {
+public final class SwitchNode: ASControlNode {
+    
+    // MARK: - UI Elements
+    private let trackNode: ASDisplayNode
+    private let thumbNode: ASDisplayNode
+    private let thumbView: UIVisualEffectView
+    
+    // MARK: - State
+    public var isOn: Bool = false
     public var valueUpdated: ((Bool) -> Void)?
     
-    public var frameColor = UIColor(rgb: 0xe0e0e0) {
+    // MARK: - Colors (Defaults)
+    public var frameColor: UIColor = UIColor(white: 0.0, alpha: 0.1) {
         didSet {
-            if self.isNodeLoaded {
-                if oldValue != self.frameColor {
-                    (self.view as! UISwitch).tintColor = self.frameColor
-                }
-            }
+             self.updateTrackColor()
         }
     }
-    public var handleColor = UIColor(rgb: 0xffffff) {
+    public var contentColor: UIColor = UIColor(rgb: 0x34C759) {
         didSet {
-            if self.isNodeLoaded {
-                //(self.view as! UISwitch).thumbTintColor = self.handleColor
-            }
+             self.updateTrackColor()
         }
     }
-    public var contentColor = UIColor(rgb: 0x42d451) {
-        didSet {
-            if self.isNodeLoaded {
-                if oldValue != self.contentColor {
-                    (self.view as! UISwitch).onTintColor = self.contentColor
-                }
-            }
+    public var handleColor: UIColor = .white // Thumb (not used much due to glass)
+    
+    // MARK: - Physics
+    private let springStiffness: CGFloat = 750.0
+    private let springDamping: CGFloat = 88.0
+    
+    // MARK: - Init
+    override public init() {
+        // 1. Create Track
+        self.trackNode = ASDisplayNode()
+        self.trackNode.cornerRadius = 15.5
+        self.trackNode.backgroundColor = self.frameColor
+        
+        // 2. Create Thumb (The Glass Container)
+        self.thumbNode = ASDisplayNode()
+        
+        // 3. Create the Glass Effect
+        let effect = UIBlurEffect(style: .systemMaterialLight)
+        self.thumbView = UIVisualEffectView(effect: effect)
+        self.thumbView.clipsToBounds = true
+        self.thumbView.layer.cornerRadius = 13.5 
+        self.thumbView.isUserInteractionEnabled = false
+        
+        super.init()
+        
+        // Hierarchy
+        self.addSubnode(self.trackNode)
+        self.addSubnode(self.thumbNode)
+        
+        // Wrap the UIKit view in the Node
+        self.thumbNode.setViewBlock { [weak self] in
+            return self?.thumbView ?? UIView()
         }
+        
+        // Interaction
+        self.addTarget(self, action: #selector(self.tapped), forControlEvents: .touchUpInside)
     }
     
-    private var _isOn: Bool = false
-    public var isOn: Bool {
-        get {
-            return self._isOn
-        } set(value) {
-            if (value != self._isOn) {
-                self._isOn = value
-                if self.isNodeLoaded {
-                    (self.view as! UISwitch).setOn(value, animated: false)
+    // MARK: - The Glass Hack (Private API)
+    // Applied when the view is loaded
+    override public func didLoad() {
+        super.didLoad()
+        self.applyGlassFilters()
+    }
+    
+    private func applyGlassFilters() {
+        DispatchQueue.main.async { [weak self] in
+            guard let self = self else { return }
+            // Iterate to find backdrop layer
+            for subview in self.thumbView.subviews {
+                if let sublayer = subview.layer.sublayers?.first(where: { $0.name == "backdrop" } ) ?? subview.layer.sublayers?.first {
+                    if let filters = sublayer.filters as? [NSObject] {
+                        for filter in filters {
+                            let filterName = filter.value(forKey: "name") as? String
+                            if filterName == "gaussianBlur" {
+                                filter.setValue(20.0, forKey: "inputRadius") // Slightly smaller radius for small thumb
+                            }
+                            if filterName == "colorSaturate" {
+                                filter.setValue(2.0, forKey: "inputAmount")
+                            }
+                        }
+                    }
                 }
             }
         }
     }
     
-    override public init() {
-        super.init()
-        
-        self.setViewBlock({
-            return SwitchNodeView()
-        })
+    // MARK: - Layout
+    override public func calculateSizeThatFits(_ constrainedSize: CGSize) -> CGSize {
+        return CGSize(width: 51.0, height: 31.0)
     }
     
-    override open func didLoad() {
-        super.didLoad()
+    override public func layout() {
+        super.layout()
+        
+        let size = self.bounds.size
+        
+        // Track fills the switch
+        self.trackNode.frame = CGRect(origin: .zero, size: size)
         
-        self.view.isAccessibilityElement = false
+        // Thumb Position
+        let thumbSize = CGSize(width: 27.0, height: 27.0)
+        let inset: CGFloat = 2.0
         
-        (self.view as! UISwitch).backgroundColor = self.backgroundColor
-        (self.view as! UISwitch).tintColor = self.frameColor
-        (self.view as! UISwitch).onTintColor = self.contentColor
+        let startX = inset
+        let endX = size.width - thumbSize.width - inset
         
-        (self.view as! UISwitch).setOn(self._isOn, animated: false)
+        let targetX = self.isOn ? endX : startX
         
-        (self.view as! UISwitch).addTarget(self, action: #selector(switchValueChanged(_:)), for: .valueChanged)
+        // We set the frame directly. 
+        // Note: The animation happens in setOn(), this just handles initial/static layout.
+        // To avoid overriding animations during layout passes, we only set if no animation is active.
+        if self.thumbNode.layer.animationKeys() == nil {
+             self.thumbNode.frame = CGRect(x: targetX, y: inset, width: thumbSize.width, height: thumbSize.height)
+        }
     }
     
-    public func setOn(_ value: Bool, animated: Bool) {
-        self._isOn = value
-        if self.isNodeLoaded {
-            (self.view as! UISwitch).setOn(value, animated: animated)
+    // MARK: - API
+    public func setOn(_ on: Bool, animated: Bool) {
+        guard self.isOn != on else { return }
+        self.isOn = on
+        
+        // Update Track Color
+        self.updateTrackColor(animated: animated)
+        
+        if animated {
+            // Animate Thumb Position (Spring)
+            let size = self.bounds.size
+            let thumbSize = CGSize(width: 27.0, height: 27.0)
+            let inset: CGFloat = 2.0
+            let startX = inset
+            let endX = size.width - thumbSize.width - inset
+            let targetX = on ? endX : startX
+            
+            let newFrame = CGRect(x: targetX, y: inset, width: thumbSize.width, height: thumbSize.height)
+            
+            let animation = CASpringAnimation(keyPath: "position")
+            animation.stiffness = self.springStiffness
+            animation.damping = self.springDamping
+            animation.mass = 1.0
+            animation.fromValue = NSValue(cgPoint: self.thumbNode.position)
+            animation.toValue = NSValue(cgPoint: CGPoint(x: newFrame.midX, y: newFrame.midY))
+            animation.duration = animation.settlingDuration
+            animation.fillMode = .forwards
+            animation.isRemovedOnCompletion = false
+            
+            self.thumbNode.layer.add(animation, forKey: "pos")
+            self.thumbNode.position = CGPoint(x: newFrame.midX, y: newFrame.midY)
+            
+        } else {
+            self.setNeedsLayout()
         }
     }
     
-    override open func calculateSizeThatFits(_ constrainedSize: CGSize) -> CGSize {
-        if #available(iOS 26.0, *) {
-            return CGSize(width: 63.0, height: 28.0)
+    private func updateTrackColor(animated: Bool = false) {
+        let targetColor = self.isOn ? self.contentColor : self.frameColor
+        if animated {
+             UIView.animate(withDuration: 0.3) {
+                self.trackNode.view.backgroundColor = targetColor
+            }
         } else {
-            return CGSize(width: 51.0, height: 31.0)
+            self.trackNode.backgroundColor = targetColor
         }
     }
     
-    @objc func switchValueChanged(_ view: UISwitch) {
-        self._isOn = view.isOn
-        self.valueUpdated?(view.isOn)
+    @objc private func tapped() {
+        self.setOn(!self.isOn, animated: true)
+        self.valueUpdated?(self.isOn)
     }
 }
diff --git a/submodules/TelegramUI/Components/Chat/ChatTextInputActionButtonsNode/Sources/ChatTextInputActionButtonsNode.swift b/submodules/TelegramUI/Components/Chat/ChatTextInputActionButtonsNode/Sources/ChatTextInputActionButtonsNode.swift
index a4e00c92e0..5583404443 100644
--- a/submodules/TelegramUI/Components/Chat/ChatTextInputActionButtonsNode/Sources/ChatTextInputActionButtonsNode.swift
+++ b/submodules/TelegramUI/Components/Chat/ChatTextInputActionButtonsNode/Sources/ChatTextInputActionButtonsNode.swift
@@ -19,6 +19,79 @@ import GlassBackgroundComponent
 import ComponentDisplayAdapters
 import StarsParticleEffect
 
+// MARK: - Glass Action Button Background
+private final class GlassActionButtonBackground: UIView {
+    private let blurView: UIVisualEffectView
+    public let contentView: UIView
+    
+    override public init(frame: CGRect) {
+        let effect = UIBlurEffect(style: .systemMaterialLight)
+        self.blurView = UIVisualEffectView(effect: effect)
+        self.blurView.clipsToBounds = true
+        self.blurView.layer.cornerRadius = 14.0
+        self.blurView.isUserInteractionEnabled = false
+        
+        self.contentView = UIView()
+        
+        super.init(frame: frame)
+        
+        self.addSubview(self.blurView)
+        self.addSubview(self.contentView)
+        
+        // Shadow for pop
+        self.layer.shadowColor = UIColor.black.cgColor
+        self.layer.shadowOffset = CGSize(width: 0.0, height: 2.0)
+        self.layer.shadowOpacity = 0.3
+        self.layer.shadowRadius = 4.0
+        
+        self.applyGlassFilters()
+    }
+    
+    required init?(coder: NSCoder) {
+        fatalError("init(coder:) has not been implemented")
+    }
+    
+    override public func layoutSubviews() {
+        super.layoutSubviews()
+        self.blurView.frame = self.bounds
+        self.contentView.frame = self.bounds
+    }
+    
+    public func update(size: CGSize, cornerRadius: CGFloat, isDark: Bool, tintColor: GlassBackgroundView.TintColor, isInteractive: Bool, transition: ComponentTransition) {
+        // We ensure a minimum corner radius to keep it roundish if needed, or follow input
+        transition.setFrame(view: self.blurView, frame: CGRect(origin: .zero, size: size))
+        transition.setCornerRadius(layer: self.blurView.layer, cornerRadius: cornerRadius)
+        transition.setFrame(view: self.contentView, frame: CGRect(origin: .zero, size: size))
+    }
+    
+    public func animateScale(_ scaled: Bool) {
+        let scale: CGFloat = scaled ? 1.15 : 1.0
+        let transition: ContainedViewLayoutTransition = .animated(duration: 0.3, curve: .spring)
+        transition.updateTransformScale(layer: self.layer, scale: scale)
+    }
+    
+    private func applyGlassFilters() {
+        DispatchQueue.main.async { [weak self] in
+            guard let self = self else { return }
+            for subview in self.blurView.subviews {
+                if let sublayer = subview.layer.sublayers?.first(where: { $0.name == "backdrop" } ) ?? subview.layer.sublayers?.first {
+                    if let filters = sublayer.filters as? [NSObject] {
+                        for filter in filters {
+                            let filterName = filter.value(forKey: "name") as? String
+                            if filterName == "gaussianBlur" {
+                                filter.setValue(20.0, forKey: "inputRadius")
+                            }
+                            if filterName == "colorSaturate" {
+                                filter.setValue(2.0, forKey: "inputAmount")
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+}
+
 private final class EffectBadgeView: UIView {
     private let context: AccountContext
     private var currentEffectId: Int64?
@@ -134,7 +207,7 @@ public final class ChatTextInputActionButtonsNode: ASDisplayNode, ChatSendMessag
     private let presentationContext: ChatPresentationContext?
     private let strings: PresentationStrings
     
-    public let micButtonBackgroundView: GlassBackgroundView
+    private let micButtonBackgroundView: GlassActionButtonBackground
     public let micButtonTintMaskView: UIImageView
     public let micButton: ChatTextInputMediaRecordingButton
     
@@ -149,7 +222,7 @@ public final class ChatTextInputActionButtonsNode: ASDisplayNode, ChatSendMessag
     public let textNode: ImmediateAnimatedCountLabelNode
     
     public let expandMediaInputButton: HighlightTrackingButton
-    private let expandMediaInputButtonBackgroundView: GlassBackgroundView
+    private let expandMediaInputButtonBackgroundView: GlassActionButtonBackground
     private let expandMediaInputButtonIcon: GlassBackgroundView.ContentImageView
     
     private var effectBadgeView: EffectBadgeView?
@@ -180,7 +253,7 @@ public final class ChatTextInputActionButtonsNode: ASDisplayNode, ChatSendMessag
         let strings = presentationInterfaceState.strings
         self.strings = strings
         
-        self.micButtonBackgroundView = GlassBackgroundView()
+        self.micButtonBackgroundView = GlassActionButtonBackground(frame: CGRect())
         self.maskContentView = UIView()
         
         self.micButtonTintMaskView = UIImageView()
@@ -200,7 +273,7 @@ public final class ChatTextInputActionButtonsNode: ASDisplayNode, ChatSendMessag
         self.textNode.isUserInteractionEnabled = false
         
         self.expandMediaInputButton = HighlightTrackingButton()
-        self.expandMediaInputButtonBackgroundView = GlassBackgroundView()
+        self.expandMediaInputButtonBackgroundView = GlassActionButtonBackground(frame: CGRect())
         self.expandMediaInputButtonBackgroundView.isUserInteractionEnabled = false
         self.expandMediaInputButton.addSubview(self.expandMediaInputButtonBackgroundView)
         self.expandMediaInputButtonIcon = GlassBackgroundView.ContentImageView()
@@ -249,9 +322,9 @@ public final class ChatTextInputActionButtonsNode: ASDisplayNode, ChatSendMessag
                 return
             }
             if highlighted {
-                self.expandMediaInputButton.layer.animateScale(from: 1.0, to: 0.75, duration: 0.4, removeOnCompletion: false)
-            } else if let presentationLayer = self.expandMediaInputButton.layer.presentation() {
-                self.expandMediaInputButton.layer.animateScale(from: CGFloat((presentationLayer.value(forKeyPath: "transform.scale.y") as? NSNumber)?.floatValue ?? 1.0), to: 1.0, duration: 0.25, removeOnCompletion: false)
+                self.expandMediaInputButtonBackgroundView.animateScale(true)
+            } else {
+                self.expandMediaInputButtonBackgroundView.animateScale(false)
             }
         }
     }
@@ -269,7 +342,7 @@ public final class ChatTextInputActionButtonsNode: ASDisplayNode, ChatSendMessag
             strongSelf.sendButtonLongPressed?(strongSelf, recognizer)
         }
         
-        self.micButtonPointerInteraction = PointerInteraction(view: self.micButton, style: .circle(36.0))
+        self.micButtonPointerInteraction = PointerInteraction(view: self.micButton, customInteractionView: self.micButtonBackgroundView, style: .lift)
         self.sendButtonPointerInteraction = PointerInteraction(view: self.sendButton.view, customInteractionView: self.sendButtonBackgroundView, style: .lift)
     }
     
diff --git a/submodules/TelegramUI/Components/Chat/ChatTextInputPanelNode/Sources/ChatTextInputPanelNode.swift b/submodules/TelegramUI/Components/Chat/ChatTextInputPanelNode/Sources/ChatTextInputPanelNode.swift
index 903663967c..c123d19a6f 100644
--- a/submodules/TelegramUI/Components/Chat/ChatTextInputPanelNode/Sources/ChatTextInputPanelNode.swift
+++ b/submodules/TelegramUI/Components/Chat/ChatTextInputPanelNode/Sources/ChatTextInputPanelNode.swift
@@ -59,6 +59,78 @@ import ChatRecordingPreviewInputPanelNode
 import ChatInputContextPanelNode
 import RasterizedCompositionComponent
 
+// MARK: - Glass Knob View
+private final class GlassKnobView: UIView {
+    private let blurView: UIVisualEffectView
+    public let contentView: UIView
+    
+    override public init(frame: CGRect) {
+        let effect = UIBlurEffect(style: .systemMaterialLight)
+        self.blurView = UIVisualEffectView(effect: effect)
+        self.blurView.clipsToBounds = true
+        self.blurView.layer.cornerRadius = 14.0
+        self.blurView.isUserInteractionEnabled = false
+        
+        self.contentView = UIView()
+        
+        super.init(frame: frame)
+        
+        self.addSubview(self.blurView)
+        self.addSubview(self.contentView)
+        
+        // Shadow for pop
+        self.layer.shadowColor = UIColor.black.cgColor
+        self.layer.shadowOffset = CGSize(width: 0.0, height: 2.0)
+        self.layer.shadowOpacity = 0.3
+        self.layer.shadowRadius = 4.0
+        
+        self.applyGlassFilters()
+    }
+    
+    required init?(coder: NSCoder) {
+        fatalError("init(coder:) has not been implemented")
+    }
+    
+    override public func layoutSubviews() {
+        super.layoutSubviews()
+        self.blurView.frame = self.bounds
+        self.contentView.frame = self.bounds
+    }
+    
+    public func update(size: CGSize, cornerRadius: CGFloat, isDark: Bool, tintColor: GlassBackgroundView.TintColor, isInteractive: Bool, transition: ComponentTransition) {
+        transition.setFrame(view: self.blurView, frame: CGRect(origin: .zero, size: size))
+        transition.setCornerRadius(layer: self.blurView.layer, cornerRadius: cornerRadius)
+        transition.setFrame(view: self.contentView, frame: CGRect(origin: .zero, size: size))
+    }
+    
+    public func animateScale(_ scaled: Bool) {
+        let scale: CGFloat = scaled ? 1.15 : 1.0
+        let transition: ContainedViewLayoutTransition = .animated(duration: 0.3, curve: .spring)
+        transition.updateTransformScale(layer: self.layer, scale: scale)
+    }
+    
+    private func applyGlassFilters() {
+        DispatchQueue.main.async { [weak self] in
+            guard let self = self else { return }
+            for subview in self.blurView.subviews {
+                if let sublayer = subview.layer.sublayers?.first(where: { $0.name == "backdrop" } ) ?? subview.layer.sublayers?.first {
+                    if let filters = sublayer.filters as? [NSObject] {
+                        for filter in filters {
+                            let filterName = filter.value(forKey: "name") as? String
+                            if filterName == "gaussianBlur" {
+                                filter.setValue(20.0, forKey: "inputRadius")
+                            }
+                            if filterName == "colorSaturate" {
+                                filter.setValue(2.0, forKey: "inputAmount")
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+}
+
 private let counterFont = Font.with(size: 14.0, design: .regular, traits: [.monospacedNumbers])
 
 public let chatTextInputMinFontSize: CGFloat = 5.0
@@ -261,7 +333,7 @@ public class ChatTextInputPanelNode: ChatInputPanelNode, ASEditableTextNodeDeleg
     private let sendAsCloseIconView: UIImageView
     
     public let attachmentButton: HighlightTrackingButton
-    public let attachmentButtonBackground: GlassBackgroundView
+    private let attachmentButtonBackground: GlassKnobView
     public let attachmentButtonIcon: GlassBackgroundView.ContentImageView
     private var commentsButtonIcon: RasterizedCompositionMonochromeLayer?
     private var commentsButtonCenterIcon: UIImageView?
@@ -688,9 +760,19 @@ public class ChatTextInputPanelNode: ChatInputPanelNode, ASEditableTextNodeDeleg
         self.attachmentButton.accessibilityTraits = [.button]
         self.attachmentButton.isAccessibilityElement = true
         
-        self.attachmentButtonBackground = GlassBackgroundView(frame: CGRect())
+        self.attachmentButtonBackground = GlassKnobView(frame: CGRect())
         self.attachmentButtonBackground.contentView.addSubview(self.attachmentButton)
         
+        self.attachmentButton.highligthedChanged = { [weak self] highlighted in
+            if let self {
+                if highlighted {
+                    self.attachmentButtonBackground.animateScale(true)
+                } else {
+                    self.attachmentButtonBackground.animateScale(false)
+                }
+            }
+        }
+        
         self.attachmentButtonIcon = GlassBackgroundView.ContentImageView()
         self.attachmentButtonIcon.isUserInteractionEnabled = false
         self.attachmentButtonBackground.contentView.addSubview(self.attachmentButtonIcon)
diff --git a/submodules/TelegramUI/Components/LiquidLens/Sources/LiquidLensView.swift b/submodules/TelegramUI/Components/LiquidLens/Sources/LiquidLensView.swift
index e5d1e84948..c9f0d90966 100644
--- a/submodules/TelegramUI/Components/LiquidLens/Sources/LiquidLensView.swift
+++ b/submodules/TelegramUI/Components/LiquidLens/Sources/LiquidLensView.swift
@@ -1,373 +1,172 @@
 import Foundation
 import UIKit
+import QuartzCore
 import Display
 import ComponentFlow
-import GlassBackgroundComponent
 
-private final class RestingBackgroundView: UIVisualEffectView {
-    var isDark: Bool?
-
-    static func colorMatrix(isDark: Bool) -> [Float32] {
-        if isDark {
-            return [1.082, -0.113, -0.011, 0.0, 0.135, -0.034, 1.003, -0.011, 0.0, 0.135, -0.034, -0.113, 1.105, 0.0, 0.135, 0.0, 0.0, 0.0, 1.0, 0.0]
-        } else {
-            return [1.185, -0.05, -0.005, 0.0, -0.2, -0.015, 1.15, -0.005, 0.0, -0.2, -0.015, -0.05, 1.195, 0.0, -0.2, 0.0, 0.0, 0.0, 1.0, 0.0]
-        }
-    }
-
-    init() {
-        let effect = UIBlurEffect(style: .light)
-        super.init(effect: effect)
-        
-        for subview in self.subviews {
-            if subview.description.contains("VisualEffectSubview") {
-                subview.isHidden = true
-            }
+// MARK: - Velocity Tracker
+// Helper to calculate how fast the lens is moving to create the "stretch"
+private final class LiquidVelocityTracker {
+    private var previousValue: CGFloat = 0.0
+    private var previousTime: CFTimeInterval = 0.0
+    var velocity: CGFloat = 0.0
+    
+    func update(value: CGFloat) {
+        let currentTime = CACurrentMediaTime()
+        let dt = CGFloat(currentTime - previousTime)
+        if dt > 0.001 {
+            let currentVelocity = (value - previousValue) / dt
+            // Low-pass filter to smooth out jitter
+            self.velocity = self.velocity * 0.7 + currentVelocity * 0.3
         }
-        
-        self.clipsToBounds = true
+        self.previousValue = value
+        self.previousTime = currentTime
     }
     
-    required init?(coder: NSCoder) {
-        fatalError("init(coder:) has not been implemented")
-    }
-
-    func update(isDark: Bool) {
-        if self.isDark == isDark {
-            return
-        }
-        self.isDark = isDark
-        
-        if let sublayer = self.layer.sublayers?[0], let _ = sublayer.filters {
-            sublayer.backgroundColor = nil
-            sublayer.isOpaque = false
-            
-            if let classValue = NSClassFromString("CAFilter") as AnyObject as? NSObjectProtocol {
-                let makeSelector = NSSelectorFromString("filterWithName:")
-                let filter = classValue.perform(makeSelector, with: "colorMatrix").takeUnretainedValue() as? NSObject
-                
-                if let filter {
-                    var matrix: [Float32] = RestingBackgroundView.colorMatrix(isDark: isDark)
-                    filter.setValue(NSValue(bytes: &matrix, objCType: "{CAColorMatrix=ffffffffffffffffffff}"), forKey: "inputColorMatrix")
-                    sublayer.filters = [filter]
-                    sublayer.setValue(1.0, forKey: "scale")
-                }
-            }
-        }
+    func reset(value: CGFloat) {
+        self.previousValue = value
+        self.velocity = 0.0
+        self.previousTime = CACurrentMediaTime()
     }
 }
 
+// MARK: - The Liquid Lens
 public final class LiquidLensView: UIView {
-    private struct Params: Equatable {
-        var size: CGSize
-        var selectionX: CGFloat
-        var selectionWidth: CGFloat
-        var isDark: Bool
-        var isLifted: Bool
-
-        init(size: CGSize, selectionX: CGFloat, selectionWidth: CGFloat, isDark: Bool, isLifted: Bool) {
-            self.size = size
-            self.selectionX = selectionX
-            self.selectionWidth = selectionWidth
-            self.isLifted = isLifted
-            self.isDark = isDark
-        }
-    }
-
-    private struct LensParams: Equatable {
-        var baseFrame: CGRect
-        var isLifted: Bool
-
-        init(baseFrame: CGRect, isLifted: Bool) {
-            self.baseFrame = baseFrame
-            self.isLifted = isLifted
-        }
-    }
-
-    private let containerView: UIView
-    private let backgroundContainerContainer: UIView
-    private let backgroundContainer: GlassBackgroundContainerView
-    private let backgroundView: GlassBackgroundView
-    private var lensView: UIView?
-    private let liftedContainerView: UIView
-    public let contentView: UIView
-    private let restingBackgroundView: RestingBackgroundView
     
-    private var legacySelectionView: GlassBackgroundView.ContentImageView?
-    private var legacyContentMaskView: UIView?
-    private var legacyContentMaskBlobView: UIImageView?
-    private var legacyLiftedContentBlobMaskView: UIImageView?
-
-    public var selectedContentView: UIView {
-        return self.liftedContainerView
-    }
-
-    private var params: Params?
-    private var appliedLensParams: LensParams?
-    private var isApplyingLensParams: Bool = false
-    private var pendingLensParams: LensParams?
-
-    private var liftedDisplayLink: SharedDisplayLinkDriver.Link?
-
-    public var selectionX: CGFloat? {
-        return self.params?.selectionX
-    }
-
-    public var selectionWidth: CGFloat? {
-        return self.params?.selectionWidth
-    }
-
+    private let blurView: UIVisualEffectView
+    private let maskLayer: CAShapeLayer
+    private let velocityTracker = LiquidVelocityTracker()
+    
+    // Telegram Physics Constants
+    private let springStiffness: CGFloat = 750.0
+    private let springDamping: CGFloat = 88.0
+    
+    // Glass Look Constants
+    private let glassBlurRadius: CGFloat = 30.0
+    private let glassSaturation: CGFloat = 1.8
+    
     override public init(frame: CGRect) {
-        self.containerView = UIView()
-        
-        self.backgroundContainerContainer = UIView()
-        self.backgroundContainer = GlassBackgroundContainerView()
+        // 1. Setup the Blur
+        // We use a light material, but we will override its filters
+        let effect = UIBlurEffect(style: .systemMaterialLight)
+        self.blurView = UIVisualEffectView(effect: effect)
+        self.blurView.autoresizingMask = [.flexibleWidth, .flexibleHeight]
         
-        self.backgroundView = GlassBackgroundView()
+        // 2. Setup the Mask (This creates the shape)
+        self.maskLayer = CAShapeLayer()
+        self.maskLayer.fillColor = UIColor.black.cgColor // Opacity doesn't matter for masks
+        self.maskLayer.cornerCurve = .continuous
         
-        self.contentView = UIView()
-        self.liftedContainerView = UIView()
-
-        self.restingBackgroundView = RestingBackgroundView()
-
         super.init(frame: frame)
         
-        self.backgroundContainerContainer.addSubview(self.backgroundContainer)
-        self.addSubview(self.backgroundContainerContainer)
-        
-        self.backgroundContainer.contentView.addSubview(self.backgroundView)
-        self.backgroundView.contentView.addSubview(self.containerView)
-        self.containerView.isUserInteractionEnabled = false
-        
-        if #available(iOS 26.0, *) {
-            if let viewClass = NSClassFromString("_UILiquidLensView") as AnyObject as? NSObjectProtocol {
-                let allocSelector = NSSelectorFromString("alloc")
-                let initSelector = NSSelectorFromString("initWithRestingBackground:")
-                let objcAlloc = viewClass.perform(allocSelector).takeUnretainedValue()
-                let instance = objcAlloc.perform(initSelector, with: UIView()).takeUnretainedValue()
-                self.lensView = instance as? UIView
-            }
-        }
+        self.addSubview(self.blurView)
+        self.layer.mask = self.maskLayer
         
-        if let lensView = self.lensView {
-            self.backgroundContainer.layer.zPosition = 1
-            lensView.layer.zPosition = 10.0
-            
-            self.liftedContainerView.addSubview(self.restingBackgroundView)
-            
-            self.containerView.addSubview(self.liftedContainerView)
-            self.containerView.addSubview(lensView)
-            self.containerView.addSubview(self.contentView)
-            
-            lensView.perform(NSSelectorFromString("setLiftedContainerView:"), with: self.backgroundContainer.contentView)
-            lensView.perform(NSSelectorFromString("setLiftedContentView:"), with: self.liftedContainerView)
-            lensView.perform(NSSelectorFromString("setOverridePunchoutView:"), with: self.contentView)
-            
-            do {
-                let selector = NSSelectorFromString("setLiftedContentMode:")
-                if let method = lensView.method(for: selector) {
-                    typealias ObjCMethod = @convention(c) (AnyObject, Selector, Int32) -> Void
-                    let function = unsafeBitCast(method, to: ObjCMethod.self)
-                    function(lensView, selector, 1)
-                }
-            }
-            
-            do {
-                let selector = NSSelectorFromString("setStyle:")
-                if let method = lensView.method(for: selector) {
-                    typealias ObjCMethod = @convention(c) (AnyObject, Selector, Int32) -> Void
-                    let function = unsafeBitCast(method, to: ObjCMethod.self)
-                    function(lensView, selector, 1)
-                }
-            }
-            
-            do {
-                let selector = NSSelectorFromString("setWarpsContentBelow:")
-                if let method = lensView.method(for: selector) {
-                    typealias ObjCMethod = @convention(c) (AnyObject, Selector, Bool) -> Void
-                    let function = unsafeBitCast(method, to: ObjCMethod.self)
-                    function(lensView, selector, true)
-                }
-            }
-            
-            lensView.setValue(UIColor(white: 0.0, alpha: 0.1), forKey: "restingBackgroundColor")
-        } else {
-            let legacySelectionView = GlassBackgroundView.ContentImageView()
-            self.legacySelectionView = legacySelectionView
-            self.backgroundView.contentView.insertSubview(legacySelectionView, at: 0)
-            
-            let legacyContentMaskView = UIView()
-            legacyContentMaskView.backgroundColor = .white
-            self.legacyContentMaskView = legacyContentMaskView
-            self.contentView.mask = legacyContentMaskView
-            
-            if let filter = CALayer.luminanceToAlpha() {
-                legacyContentMaskView.layer.filters = [filter]
-            }
-            
-            let legacyContentMaskBlobView = UIImageView()
-            self.legacyContentMaskBlobView = legacyContentMaskBlobView
-            legacyContentMaskView.addSubview(legacyContentMaskBlobView)
-            
-            self.containerView.addSubview(self.contentView)
-            
-            let legacyLiftedContentBlobMaskView = UIImageView()
-            self.legacyLiftedContentBlobMaskView = legacyLiftedContentBlobMaskView
-            self.liftedContainerView.mask = legacyLiftedContentBlobMaskView
-            
-            self.containerView.addSubview(self.liftedContainerView)
-        }
+        // 3. Apply the "Hard Glass" Filters immediately
+        self.applyGlassFilters()
     }
-
+    
     required init?(coder: NSCoder) {
         fatalError("init(coder:) has not been implemented")
     }
-
-    public func update(size: CGSize, selectionX: CGFloat, selectionWidth: CGFloat, isDark: Bool, isLifted: Bool, transition: ComponentTransition) {
-        let params = Params(size: size, selectionX: selectionX, selectionWidth: selectionWidth, isDark: isDark, isLifted: isLifted)
-        if self.params == params {
-            return
-        }
-        self.update(params: params, transition: transition)
-    }
-
-    private func update(transition: ComponentTransition) {
-        guard let params = self.params else {
-            return
-        }
-        self.update(params: params, transition: transition)
-    }
-
-    private func updateLens(params: LensParams, animated: Bool) {
-        guard let lensView = self.lensView else {
-            return
-        }
-
-        if self.isApplyingLensParams {
-            self.pendingLensParams = params
-            return
-        }
-        self.isApplyingLensParams = true
-        let previousParams = self.appliedLensParams
-
-        let transition: ComponentTransition = animated ? .easeInOut(duration: 0.3) : .immediate
-
-        if previousParams?.isLifted != params.isLifted {
-            let selector = NSSelectorFromString("setLifted:animated:alongsideAnimations:completion:")
-            var shouldScheduleUpdate = false
-            var didProcessUpdate = false
-            self.pendingLensParams = params
-            if let lensView = self.lensView, let method = lensView.method(for: selector) {
-                typealias ObjCMethod = @convention(c) (AnyObject, Selector, Bool, Bool, @escaping () -> Void, AnyObject?) -> Void
-                let function = unsafeBitCast(method, to: ObjCMethod.self)
-                function(lensView, selector, params.isLifted, !transition.animation.isImmediate, { [weak self] in
-                    guard let self else {
-                        return
-                    }
-                    let liftedInset: CGFloat = params.isLifted ? 4.0 : -4.0
-                    lensView.bounds = CGRect(origin: CGPoint(), size: CGSize(width: params.baseFrame.width + liftedInset * 2.0, height: params.baseFrame.height + liftedInset * 2.0))
-                    didProcessUpdate = true
-                    if shouldScheduleUpdate {
-                        DispatchQueue.main.async { [weak self] in
-                            guard let self, let pendingLensParams = self.pendingLensParams else {
-                                return
+    
+    // MARK: - Glass Hack
+    // This function digs into the CoreAnimation layer to boost blur and saturation
+    private func applyGlassFilters() {
+        DispatchQueue.main.async { [weak self] in
+            guard let self = self else { return }
+            // Iterate through private subviews to find the BackdropLayer
+            for subview in self.blurView.subviews {
+                // The backdrop layer usually has no name, or is named "backdrop"
+                if let sublayer = subview.layer.sublayers?.first(where: { $0.name == "backdrop" } ) ?? subview.layer.sublayers?.first {
+                    if let filters = sublayer.filters as? [NSObject] {
+                        for filter in filters {
+                            let filterName = filter.value(forKey: "name") as? String
+                            if filterName == "gaussianBlur" {
+                                filter.setValue(self.glassBlurRadius, forKey: "inputRadius")
+                            }
+                            if filterName == "colorSaturate" {
+                                filter.setValue(self.glassSaturation, forKey: "inputAmount")
                             }
-                            self.isApplyingLensParams = false
-                            self.pendingLensParams = nil
-                            self.updateLens(params: pendingLensParams, animated: !transition.animation.isImmediate)
                         }
                     }
-                }, nil)
-            }
-            if didProcessUpdate {
-                transition.animateView {
-                    lensView.center = CGPoint(x: params.baseFrame.midX, y: params.baseFrame.midY)
                 }
-                self.pendingLensParams = nil
-                self.isApplyingLensParams = false
-            } else {
-                shouldScheduleUpdate = true
-            }
-        } else {
-            transition.animateView {
-                let liftedInset: CGFloat = params.isLifted ? 4.0 : -4.0
-                lensView.bounds = CGRect(origin: CGPoint(), size: CGSize(width: params.baseFrame.width + liftedInset * 2.0, height: params.baseFrame.height + liftedInset * 2.0))
-                lensView.center = CGPoint(x: params.baseFrame.midX, y: params.baseFrame.midY)
             }
-            self.isApplyingLensParams = false
-        }
-    }
-
-    private func updateLiftedLensPosition() {
-        // Without this, the lens won't update its bouncing animations unless it's being moved
-        if self.isApplyingLensParams {
-            return
-        }
-        guard let lensView = self.lensView else {
-            return
-        }
-        guard let params = self.appliedLensParams else {
-            return
         }
-        lensView.center = CGPoint(x: params.baseFrame.midX, y: params.baseFrame.midY)
     }
-
-    private func update(params: Params, transition: ComponentTransition) {
-        let isFirstTime = self.params == nil
-        let transition: ComponentTransition = isFirstTime ? .immediate : transition
-
-        self.params = params
-
-        transition.setFrame(view: self.containerView, frame: CGRect(origin: CGPoint(), size: params.size))
-        transition.setFrame(view: self.backgroundContainerContainer, frame: CGRect(origin: CGPoint(), size: params.size))
-
-        transition.setFrame(view: self.backgroundContainer, frame: CGRect(origin: CGPoint(), size: params.size))
-        self.backgroundContainer.update(size: params.size, isDark: params.isDark, transition: transition)
+    
+    // MARK: - The Update Loop
+    public func update(
+        size: CGSize,
+        selectionX: CGFloat,
+        selectionWidth: CGFloat,
+        isDark: Bool,
+        isLifted: Bool,
+        transition: ComponentTransition
+    ) {
+        // 1. Ensure the view covers the whole area (Mask handles visibility)
+        transition.setFrame(view: self, frame: CGRect(origin: .zero, size: size))
+        transition.setFrame(view: self.blurView, frame: self.bounds)
         
-        transition.setFrame(view: self.backgroundView, frame: CGRect(origin: CGPoint(), size: params.size))
-        self.backgroundView.update(size: params.size, cornerRadius: params.size.height * 0.5, isDark: params.isDark, tintColor: GlassBackgroundView.TintColor.init(kind: .panel, color: UIColor(white: params.isDark ? 0.0 : 1.0, alpha: 0.6)), isInteractive: true, transition: transition)
+        // 2. Calculate Velocity & Stretch
+        self.velocityTracker.update(value: selectionX)
         
-        transition.setFrame(view: self.contentView, frame: CGRect(origin: CGPoint(), size: params.size))
-        transition.setFrame(view: self.liftedContainerView, frame: CGRect(origin: CGPoint(), size: params.size))
-
-        let baseLensFrame = CGRect(origin: CGPoint(x: max(0.0, min(params.selectionX, params.size.width - params.selectionWidth)), y: 0.0), size: CGSize(width: params.selectionWidth, height: params.size.height))
-        self.updateLens(params: LensParams(baseFrame: baseLensFrame, isLifted: params.isLifted), animated: !transition.animation.isImmediate)
+        // Stretch math: 
+        // fast movement = wider blob. Max stretch limited to 25pts.
+        let stretchAmount = min(abs(self.velocityTracker.velocity) * 0.0008, 25.0)
+        let dynamicWidth = selectionWidth + stretchAmount
         
-        if let legacyContentMaskView = self.legacyContentMaskView {
-            transition.setFrame(view: legacyContentMaskView, frame: CGRect(origin: CGPoint(), size: params.size))
+        // 3. Calculate Position
+        // Assuming selectionX is the CENTER of the tab.
+        // If selectionX is leading edge, remove the subtraction.
+        // We add lag/overshoot logic via the spring animation later.
+        let centerX = selectionX
+        let centerY = size.height / 2.0
+        
+        let blobRect = CGRect(
+            x: centerX - (dynamicWidth / 2.0),
+            y: centerY - (50.0 / 2.0), // Assuming 50pt height for the lens
+            width: dynamicWidth,
+            height: 50.0
+        )
+        
+        // 4. Create the Path
+        let path = UIBezierPath(roundedRect: blobRect, cornerRadius: blobRect.height / 2.0)
+        
+        // Determine Animation Duration safely
+        var animationDuration: Double = 0.0
+        if case let .animated(duration, _) = transition.animation {
+            animationDuration = duration
         }
-        if let legacyContentMaskBlobView = self.legacyContentMaskBlobView, let legacyLiftedContentBlobMaskView = self.legacyLiftedContentBlobMaskView, let legacySelectionView = self.legacySelectionView {
-            let lensFrame = baseLensFrame.insetBy(dx: 4.0, dy: 4.0)
-            let effectiveLensFrame = lensFrame.insetBy(dx: params.isLifted ? -2.0 : 0.0, dy: params.isLifted ? -2.0 : 0.0)
-            
-            if legacyContentMaskBlobView.image?.size.height != lensFrame.height {
-                legacyContentMaskBlobView.image = generateStretchableFilledCircleImage(diameter: lensFrame.height, color: .black)
-                legacyLiftedContentBlobMaskView.image = legacyContentMaskBlobView.image
-                legacySelectionView.image = generateStretchableFilledCircleImage(diameter: lensFrame.height, color: .white)?.withRenderingMode(.alwaysTemplate)
-            }
-            transition.setFrame(view: legacyContentMaskBlobView, frame: effectiveLensFrame)
-            transition.setFrame(view: legacyLiftedContentBlobMaskView, frame: effectiveLensFrame)
-            
-            legacySelectionView.tintColor = UIColor(white: params.isDark ? 1.0 : 0.0, alpha: params.isDark ? 0.1 : 0.075)
-            transition.setFrame(view: legacySelectionView, frame: effectiveLensFrame)
+        
+        // 5. Animate the Mask Path
+        // We use a Custom CASpringAnimation to match Telegram's physics exactly
+        let pathAnimation = CASpringAnimation(keyPath: "path")
+        pathAnimation.duration = animationDuration // Use transition duration
+        pathAnimation.damping = self.springDamping
+        pathAnimation.stiffness = self.springStiffness
+        pathAnimation.mass = 1.0
+        pathAnimation.fromValue = self.maskLayer.presentation()?.path ?? self.maskLayer.path
+        pathAnimation.toValue = path.cgPath
+        pathAnimation.fillMode = .forwards
+        pathAnimation.isRemovedOnCompletion = false
+        
+        // Check if we are actually animating (Transition contains animation info)
+        if transition.animation.isAnimated {
+            self.maskLayer.add(pathAnimation, forKey: "path")
+            self.maskLayer.path = path.cgPath
+        } else {
+            // Immediate update (first layout or scrolling)
+            self.maskLayer.removeAllAnimations()
+            self.maskLayer.path = path.cgPath
+            self.velocityTracker.reset(value: selectionX)
         }
-
-        transition.setFrame(view: self.restingBackgroundView, frame: CGRect(origin: CGPoint(), size: params.size))
-        self.restingBackgroundView.update(isDark: params.isDark)
-        transition.setAlpha(view: self.restingBackgroundView, alpha: params.isLifted ? 0.0 : 1.0)
-
-        if params.isLifted {
-            if self.liftedDisplayLink == nil {
-                self.liftedDisplayLink = SharedDisplayLinkDriver.shared.add(framesPerSecond: .max, { [weak self] _ in
-                    guard let self else {
-                        return
-                    }
-                    self.updateLiftedLensPosition()
-                })
-            }
-        } else if let liftedDisplayLink = self.liftedDisplayLink {
-            self.liftedDisplayLink = nil
-            liftedDisplayLink.invalidate()
+        
+        // 6. Handle Dark Mode
+        let style: UIBlurEffect.Style = isDark ? .systemMaterialDark : .systemMaterialLight
+        if let currentEffect = self.blurView.effect as? UIBlurEffect, currentEffect.style != style {
+            self.blurView.effect = UIBlurEffect(style: style)
+            self.applyGlassFilters() // Re-apply hack after style change
         }
     }
 }
diff --git a/submodules/TelegramUI/Components/SliderComponent/Sources/SliderComponent.swift b/submodules/TelegramUI/Components/SliderComponent/Sources/SliderComponent.swift
index d9cffb9fe4..722324f4e6 100644
--- a/submodules/TelegramUI/Components/SliderComponent/Sources/SliderComponent.swift
+++ b/submodules/TelegramUI/Components/SliderComponent/Sources/SliderComponent.swift
@@ -6,6 +6,61 @@ import TelegramPresentationData
 import LegacyComponents
 import ComponentFlow
 
+// MARK: - Glass Knob Helper
+private final class GlassKnobView: UIView {
+    private let blurView: UIVisualEffectView
+    
+    override init(frame: CGRect) {
+        let effect = UIBlurEffect(style: .systemMaterialLight)
+        self.blurView = UIVisualEffectView(effect: effect)
+        self.blurView.clipsToBounds = true
+        self.blurView.layer.cornerRadius = 14.0 
+        self.blurView.isUserInteractionEnabled = false
+        
+        super.init(frame: frame)
+        
+        self.addSubview(self.blurView)
+        
+        // Shadow for pop
+        self.layer.shadowColor = UIColor.black.cgColor
+        self.layer.shadowOffset = CGSize(width: 0.0, height: 2.0)
+        self.layer.shadowOpacity = 0.3
+        self.layer.shadowRadius = 4.0
+        
+        self.applyGlassFilters()
+    }
+    
+    required init?(coder: NSCoder) {
+        fatalError("init(coder:) has not been implemented")
+    }
+    
+    override func layoutSubviews() {
+        super.layoutSubviews()
+        self.blurView.frame = self.bounds
+    }
+    
+    private func applyGlassFilters() {
+        DispatchQueue.main.async { [weak self] in
+            guard let self = self else { return }
+            for subview in self.blurView.subviews {
+                if let sublayer = subview.layer.sublayers?.first(where: { $0.name == "backdrop" } ) ?? subview.layer.sublayers?.first {
+                    if let filters = sublayer.filters as? [NSObject] {
+                        for filter in filters {
+                            let filterName = filter.value(forKey: "name") as? String
+                            if filterName == "gaussianBlur" {
+                                filter.setValue(20.0, forKey: "inputRadius")
+                            }
+                            if filterName == "colorSaturate" {
+                                filter.setValue(2.0, forKey: "inputAmount")
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+}
+
 public final class SliderComponent: Component {
     public final class Discrete: Equatable {
         public let valueCount: Int
@@ -124,6 +179,7 @@ public final class SliderComponent: Component {
     public final class View: UIView {
         private var nativeSliderView: SliderView?
         private var sliderView: TGPhotoEditorSliderView?
+        private let glassKnob = GlassKnobView(frame: CGRect(x: 0, y: 0, width: 28.0, height: 28.0))
         
         private var component: SliderComponent?
         private weak var state: EmptyComponentState?
@@ -134,6 +190,7 @@ public final class SliderComponent: Component {
         
         override public init(frame: CGRect) {
             super.init(frame: frame)
+            self.isUserInteractionEnabled = true
         }
         
         required public init?(coder: NSCoder) {
@@ -241,25 +298,11 @@ public final class SliderComponent: Component {
                     sliderView.backColor = component.trackBackgroundColor
                     sliderView.startColor = component.trackBackgroundColor
                     sliderView.trackColor = component.trackForegroundColor
-                    if let knobSize = component.knobSize {
-                        sliderView.knobImage = generateImage(CGSize(width: 40.0, height: 40.0), rotatedContext: { size, context in
-                            context.clear(CGRect(origin: CGPoint(), size: size))
-                            context.setShadow(offset: CGSize(width: 0.0, height: -3.0), blur: 12.0, color: UIColor(white: 0.0, alpha: 0.25).cgColor)
-                            if let knobColor = component.knobColor {
-                                context.setFillColor(knobColor.cgColor)
-                            } else {
-                                context.setFillColor(UIColor.white.cgColor)
-                            }
-                            context.fillEllipse(in: CGRect(origin: CGPoint(x: floor((size.width - knobSize) * 0.5), y: floor((size.width - knobSize) * 0.5)), size: CGSize(width: knobSize, height: knobSize)))
-                        })
-                    } else {
-                        sliderView.knobImage = generateImage(CGSize(width: 40.0, height: 40.0), rotatedContext: { size, context in
-                            context.clear(CGRect(origin: CGPoint(), size: size))
-                            context.setShadow(offset: CGSize(width: 0.0, height: -3.0), blur: 12.0, color: UIColor(white: 0.0, alpha: 0.25).cgColor)
-                            context.setFillColor(UIColor.white.cgColor)
-                            context.fillEllipse(in: CGRect(origin: CGPoint(x: 6.0, y: 6.0), size: CGSize(width: 28.0, height: 28.0)))
-                        })
-                    }
+                    
+                    // HIDE NATIVE KNOB: Use a transparent image
+                    sliderView.knobImage = generateImage(CGSize(width: 40.0, height: 40.0), rotatedContext: { size, context in
+                        context.clear(CGRect(origin: CGPoint(), size: size))
+                    })
                     
                     sliderView.frame = CGRect(origin: CGPoint(x: 0.0, y: 0.0), size: size)
                     sliderView.hitTestEdgeInsets = UIEdgeInsets(top: -sliderView.frame.minX, left: 0.0, bottom: 0.0, right: -sliderView.frame.minX)
@@ -270,6 +313,9 @@ public final class SliderComponent: Component {
                     sliderView.layer.allowsGroupOpacity = true
                     self.sliderView = sliderView
                     self.addSubview(sliderView)
+                    
+                    // Add Glass Knob on top
+                    self.addSubview(self.glassKnob)
                 }
                 sliderView.lowerBoundTrackColor = component.minTrackForegroundColor
                 switch component.content {
@@ -297,12 +343,23 @@ public final class SliderComponent: Component {
                 
                 transition.setFrame(view: sliderView, frame: CGRect(origin: CGPoint(x: 0.0, y: 0.0), size: CGSize(width: availableSize.width, height: 44.0)))
                 sliderView.hitTestEdgeInsets = UIEdgeInsets(top: 0.0, left: 0.0, bottom: 0.0, right: 0.0)
+                
+                self.syncGlassKnobPosition()
             }
             
             return size
         }
         
+        private func syncGlassKnobPosition() {
+            guard let sliderView = self.sliderView else { return }
+            // Robust method: Map the native (hidden) knob's center to our coordinate space
+            let knobCenter = sliderView.convert(sliderView.knobView.center, to: self)
+            self.glassKnob.center = knobCenter
+        }
+        
         @objc private func sliderValueChanged() {
+            self.syncGlassKnobPosition()
+            
             guard let component = self.component else {
                 return
             }
